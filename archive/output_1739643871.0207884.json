{"content": {"suites": {"0": {"status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}, "tests": {"0": {"status": "ERROR", "message": "self = <tests.test_insider_steps.TestInsiderWebsite object at 0x000001163563F7A0>\n\n    @pytest.fixture\n    def browser(self):\n        options = uc.ChromeOptions()\n        options.add_argument('--start-maximized')\n        # Headless modu i\u00e7in arg\u00fcman ekleme\n        # options.add_argument('--headless')  # E\u011fer headless mod istiyorsan\u0131z bu sat\u0131r\u0131 a\u00e7\u0131n\n>       driver = uc.Chrome(use_subprocess=True, options=options)\n\ntests\\test_insider_steps.py:14: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <undetected_chromedriver.Chrome (session=\"None\")>\noptions = <undetected_chromedriver.options.ChromeOptions object at 0x0000011633A794F0>\nuser_data_dir = 'C:\\\\Users\\\\Admin\\\\AppData\\\\Local\\\\Temp\\\\tmpny69thnr'\ndriver_executable_path = None, browser_executable_path = None, port = 0\nenable_cdp_events = False, desired_capabilities = None\nadvanced_elements = False, keep_alive = True, log_level = 0, headless = False\nversion_main = None, patcher_force_close = False, suppress_welcome = True\nuse_subprocess = True, debug = False, no_sandbox = True\nuser_multi_procs = False, kw = {}, debug_port = 57612, debug_host = '127.0.0.1'\nlanguage = 'tr-TR', keep_user_data_dir = False\narg = '--user-data-dir=C:\\\\Users\\\\Admin\\\\AppData\\\\Local\\\\Temp\\\\tmpny69thnr'\n\n    def __init__(\n        self,\n        options=None,\n        user_data_dir=None,\n        driver_executable_path=None,\n        browser_executable_path=None,\n        port=0,\n        enable_cdp_events=False,\n        desired_capabilities=None,\n        advanced_elements=False,\n        keep_alive=True,\n        log_level=0,\n        headless=False,\n        version_main=None,\n        patcher_force_close=False,\n        suppress_welcome=True,\n        use_subprocess=True,\n        debug=False,\n        no_sandbox=True,\n        user_multi_procs: bool = False,\n        **kw,\n    ):\n        \"\"\"\n        Creates a new instance of the chrome driver.\n    \n        Starts the service and then creates new instance of chrome driver.\n    \n        Parameters\n        ----------\n    \n        options: ChromeOptions, optional, default: None - automatic useful defaults\n            this takes an instance of ChromeOptions, mainly to customize browser behavior.\n            anything other dan the default, for example extensions or startup options\n            are not supported in case of failure, and can probably lowers your undetectability.\n    \n    \n        user_data_dir: str , optional, default: None (creates temp profile)\n            if user_data_dir is a path to a valid chrome profile directory, use it,\n            and turn off automatic removal mechanism at exit.\n    \n        driver_executable_path: str, optional, default: None(=downloads and patches new binary)\n    \n        browser_executable_path: str, optional, default: None - use find_chrome_executable\n            Path to the browser executable.\n            If not specified, make sure the executable's folder is in $PATH\n    \n        port: int, optional, default: 0\n            port to be used by the chromedriver executable, this is NOT the debugger port.\n            leave it at 0 unless you know what you are doing.\n            the default value of 0 automatically picks an available port.\n    \n        enable_cdp_events: bool, default: False\n            :: currently for chrome only\n            this enables the handling of wire messages\n            when enabled, you can subscribe to CDP events by using:\n    \n                driver.add_cdp_listener(\"Network.dataReceived\", yourcallback)\n                # yourcallback is an callable which accepts exactly 1 dict as parameter\n    \n    \n        service_args: list of str, optional, default: None\n            arguments to pass to the driver service\n    \n        desired_capabilities: dict, optional, default: None - auto from config\n            Dictionary object with non-browser specific capabilities only, such as \"item\" or \"loggingPref\".\n    \n        advanced_elements:  bool, optional, default: False\n            makes it easier to recognize elements like you know them from html/browser inspection, especially when working\n            in an interactive environment\n    \n            default webelement repr:\n            <selenium.webdriver.remote.webelement.WebElement (session=\"85ff0f671512fa535630e71ee951b1f2\", element=\"6357cb55-92c3-4c0f-9416-b174f9c1b8c4\")>\n    \n            advanced webelement repr\n            <WebElement(<a class=\"mobile-show-inline-block mc-update-infos init-ok\" href=\"#\" id=\"main-cat-switcher-mobile\">)>\n    \n            note: when retrieving large amounts of elements ( example: find_elements_by_tag(\"*\") ) and print them, it does take a little more time.\n    \n        log_level: int, optional, default: adapts to python global log level\n    \n        headless: bool, optional, default: False\n            can also be specified in the options instance.\n            Specify whether you want to use the browser in headless mode.\n            warning: this lowers undetectability and not fully supported.\n    \n        version_main: int, optional, default: None (=auto)\n            if you, for god knows whatever reason, use\n            an older version of Chrome. You can specify it's full rounded version number\n            here. Example: 87 for all versions of 87\n    \n        patcher_force_close: bool, optional, default: False\n            instructs the patcher to do whatever it can to access the chromedriver binary\n            if the file is locked, it will force shutdown all instances.\n            setting it is not recommended, unless you know the implications and think\n            you might need it.\n    \n        suppress_welcome: bool, optional , default: True\n            a \"welcome\" alert might show up on *nix-like systems asking whether you want to set\n            chrome as your default browser, and if you want to send even more data to google.\n            now, in case you are nag-fetishist, or a diagnostics data feeder to google, you can set this to False.\n            Note: if you don't handle the nag screen in time, the browser loses it's connection and throws an Exception.\n    \n        use_subprocess: bool, optional , default: True,\n    \n            False (the default) makes sure Chrome will get it's own process (so no subprocess of chromedriver.exe or python\n                This fixes a LOT of issues, like multithreaded run, but mst importantly. shutting corectly after\n                program exits or using .quit()\n                you should be knowing what you're doing, and know how python works.\n    \n              unfortunately, there  is always an edge case in which one would like to write an single script with the only contents being:\n              --start script--\n              import undetected_chromedriver as uc\n              d = uc.Chrome()\n              d.get('https://somesite/')\n              ---end script --\n    \n              and will be greeted with an error, since the program exists before chrome has a change to launch.\n              in that case you can set this to `True`. The browser will start via subprocess, and will keep running most of times.\n              ! setting it to True comes with NO support when being detected. !\n    \n        no_sandbox: bool, optional, default=True\n             uses the --no-sandbox option, and additionally does suppress the \"unsecure option\" status bar\n             this option has a default of True since many people seem to run this as root (....) , and chrome does not start\n             when running as root without using --no-sandbox flag.\n    \n        user_multi_procs:\n            set to true when you are using multithreads/multiprocessing\n            ensures not all processes are trying to modify a binary which is in use by another.\n            for this to work. YOU MUST HAVE AT LEAST 1 UNDETECTED_CHROMEDRIVER BINARY IN YOUR ROAMING DATA FOLDER.\n            this requirement can be easily satisfied, by just running this program \"normal\" and close/kill it.\n    \n    \n        \"\"\"\n    \n        finalize(self, self._ensure_close, self)\n        self.debug = debug\n        self.patcher = Patcher(\n            executable_path=driver_executable_path,\n            force=patcher_force_close,\n            version_main=version_main,\n            user_multi_procs=user_multi_procs,\n        )\n        # self.patcher.auto(user_multiprocess = user_multi_num_procs)\n        self.patcher.auto()\n    \n        # self.patcher = patcher\n        if not options:\n            options = ChromeOptions()\n    \n        try:\n            if hasattr(options, \"_session\") and options._session is not None:\n                #  prevent reuse of options,\n                #  as it just appends arguments, not replace them\n                #  you'll get conflicts starting chrome\n                raise RuntimeError(\"you cannot reuse the ChromeOptions object\")\n        except AttributeError:\n            pass\n    \n        options._session = self\n    \n        if not options.debugger_address:\n            debug_port = (\n                port\n                if port != 0\n                else selenium.webdriver.common.service.utils.free_port()\n            )\n            debug_host = \"127.0.0.1\"\n            options.debugger_address = \"%s:%d\" % (debug_host, debug_port)\n        else:\n            debug_host, debug_port = options.debugger_address.split(\":\")\n            debug_port = int(debug_port)\n    \n        if enable_cdp_events:\n            options.set_capability(\n                \"goog:loggingPrefs\", {\"performance\": \"ALL\", \"browser\": \"ALL\"}\n            )\n    \n        options.add_argument(\"--remote-debugging-host=%s\" % debug_host)\n        options.add_argument(\"--remote-debugging-port=%s\" % debug_port)\n    \n        if user_data_dir:\n            options.add_argument(\"--user-data-dir=%s\" % user_data_dir)\n    \n        language, keep_user_data_dir = None, bool(user_data_dir)\n    \n        # see if a custom user profile is specified in options\n        for arg in options.arguments:\n    \n            if any([_ in arg for _ in (\"--headless\", \"headless\")]):\n                options.arguments.remove(arg)\n                options.headless = True\n    \n            if \"lang\" in arg:\n                m = re.search(\"(?:--)?lang(?:[ =])?(.*)\", arg)\n                try:\n                    language = m[1]\n                except IndexError:\n                    logger.debug(\"will set the language to en-US,en;q=0.9\")\n                    language = \"en-US,en;q=0.9\"\n    \n            if \"user-data-dir\" in arg:\n                m = re.search(\"(?:--)?user-data-dir(?:[ =])?(.*)\", arg)\n                try:\n                    user_data_dir = m[1]\n                    logger.debug(\n                        \"user-data-dir found in user argument %s => %s\" % (arg, m[1])\n                    )\n                    keep_user_data_dir = True\n    \n                except IndexError:\n                    logger.debug(\n                        \"no user data dir could be extracted from supplied argument %s \"\n                        % arg\n                    )\n    \n        if not user_data_dir:\n            # backward compatiblity\n            # check if an old uc.ChromeOptions is used, and extract the user data dir\n    \n            if hasattr(options, \"user_data_dir\") and getattr(\n                options, \"user_data_dir\", None\n            ):\n                import warnings\n    \n                warnings.warn(\n                    \"using ChromeOptions.user_data_dir might stop working in future versions.\"\n                    \"use uc.Chrome(user_data_dir='/xyz/some/data') in case you need existing profile folder\"\n                )\n                options.add_argument(\"--user-data-dir=%s\" % options.user_data_dir)\n                keep_user_data_dir = True\n                logger.debug(\n                    \"user_data_dir property found in options object: %s\" % user_data_dir\n                )\n    \n            else:\n                user_data_dir = os.path.normpath(tempfile.mkdtemp())\n                keep_user_data_dir = False\n                arg = \"--user-data-dir=%s\" % user_data_dir\n                options.add_argument(arg)\n                logger.debug(\n                    \"created a temporary folder in which the user-data (profile) will be stored during this\\n\"\n                    \"session, and added it to chrome startup arguments: %s\" % arg\n                )\n    \n        if not language:\n            try:\n                import locale\n    \n                language = locale.getdefaultlocale()[0].replace(\"_\", \"-\")\n            except Exception:\n                pass\n            if not language:\n                language = \"en-US\"\n    \n        options.add_argument(\"--lang=%s\" % language)\n    \n        if not options.binary_location:\n            options.binary_location = (\n                browser_executable_path or find_chrome_executable()\n            )\n    \n        self._delay = 3\n    \n        self.user_data_dir = user_data_dir\n        self.keep_user_data_dir = keep_user_data_dir\n    \n        if suppress_welcome:\n            options.arguments.extend([\"--no-default-browser-check\", \"--no-first-run\"])\n        if no_sandbox:\n            options.arguments.extend([\"--no-sandbox\", \"--test-type\"])\n    \n>       if headless or options.headless:\nE       AttributeError: 'ChromeOptions' object has no attribute 'headless'\n\n..\\..\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python312\\site-packages\\undetected_chromedriver\\__init__.py:375: AttributeError\n", "test_name": "test_insider_website", "rerun": "0"}}, "suite_name": "tests/test_insider_steps.py"}}}, "date": "February 15, 2025", "start_time": 1739643847.667837, "total_suite": 1, "status": "FAIL", "status_list": {"pass": "0", "fail": "0", "skip": "0", "error": "1", "xpass": "0", "xfail": "0", "rerun": "0"}, "total_tests": "1"}